# Verifying Multiple Transactions

Verifying multiple transactions can be thought of as verifying several individual single transactions. As each transaction results in a new `accounts_root`, we require several updates before arriving to the final one. The circuit will just loop through all of these intermediate roots, which will have to be provided to generate a witness. For each SNARK proof, we will also construct a transaction Merkle tree, whose leaves are the transactions that have been processed. We will also add support for transacting with multiple tokens, where each of them will be represented by an integer: L2 accounts will only be able to transact in their designated token.

Withdrawals on the L2 are made by sending a transaction to the `ZERO_ADDRESS`, which is the first leaf of our account balance tree. This account is not able to generate transactions, and can only receive them. The sedond leaf of the balance tree is reserved as a known opperator leaf, used to make an arbitrary number of transactions in order to pad inputs to the circuit. To verify a withdrawal on-chain and send the user their funds back on the L1, they will need to prove that their withdrawal transaction was included as part of a transaction tree. 

The implementation will then have to check for transactions that are made to the `ZERO_ADDRESS`, as these will effectively burn the tokens: the `ZERO_ADDRESS` does not hold _any_ funds. Because circom compiles our code into arithmetic circuits, circuits whose behaviour depends on the value of an input are not supported. To get around this, we will make use of a series of helper functions, located inside [`./circuits/if_gadgets.circom`](./circuits/if_gadgets.circom). 

The implementation will therefore be able to prove a valid transition from an initial account root, `current_state`, to a new root, `out`, given a certain batch of transactions defined by its root, `tx_root`. Only these signals will be public, although we could set the remaining ones to be as well for a validity-style rollup. We will be generating a Solidity verifier for this circuit to be included as part of our smart contract.