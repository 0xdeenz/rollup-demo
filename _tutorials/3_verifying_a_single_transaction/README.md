# Verifying a Single Transaction

Going forward, we will be dealing with _Accounts_ and _Transactions_. A more formal definition for these will be of help:

```js
class Transaction = {
    from: eddsa_pubkey,
    to: eddsa_pubkey,
    from_index: integer,
    nonce: integer,
    amount: integer,
    token_type: integer
}

class Account = {
    pubkey: eddsa_pubkey,
    balance: integer,
    nonce: integer,
    token_type: integer
}

// Remember that an EdDSA public key consists of two values, the x and y coordinates for the point.
```

The leaves for the account and transaction tree will be generated by hashing these values together. Due to some constraints of the Poseidon function that we will see later, a transaction leaf will be generated by taking the root of a transaction _subtree_: the left leaf will be the result of hashing the `from` and `to` public keys, while the right leaf will be the result of hashing the other four values: `from_index`, `nonce`, `amount`, and `token_type`.

Each account is thus represented by a single leaf in the accounts tree

For our example implementation, verifying a single transaction involves multiple steps:
1. Verifying that the transaction's sender leaf exists within the account Merkle tree 
2. Verifying that the transaction was signed by the sender
3. Checking that the sender account is of the `token_type` sent, and has a sufficient balance, and afterwards debiting them
4. Updating the account Merkle tree root, `accounts_root`, to get an intermediate root, `intermediate_root`
5. Verifying that the receiver account leaf exists within the account Merkle tree
6. Checking that the receiver account is of the `token_type` sent, and afterwards crediting them with the funds
7. Updating the account Merkle tree root to get the final root, `final_root`

The provided circuit, `single_transaction.circom`, is thus able to generate a proof of a valid transaction using only the account's root as input.